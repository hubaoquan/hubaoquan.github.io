<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>hubaoquan.github.io/2017/02/12/Android%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%BB%8F%E5%85%B8/%E7%AC%AC%E4%B8%80%E8%8A%82/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git教程学习-搭建Git服务器]]></title>
      <url>hubaoquan.github.io/2017/01/23/Git/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0-Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p>
<p>假设你已经有sudo权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装git：<br><a id="more"></a></p>
<pre><code>$ sudo apt-get install git
</code></pre><p>第二步，创建一个git用户，用来运行git服务：</p>
<pre><code>$ sudo adduser git
</code></pre><p>第三步，创建证书登录：</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在/srv目录下输入命令：</p>
<pre><code>$ sudo git init --bare sample.git
</code></pre><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>
<pre><code>$ sudo chown -R git:git sample.git
</code></pre><p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre><p>改为：</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre><p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p>
<pre><code>$ git clone git@server:/srv/sample.git
Cloning into &apos;sample&apos;...
warning: You appear to have cloned an empty repository.
</code></pre><p>剩下的推送就简单了。</p>
<h3 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h3><p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p>
<p>这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p>
<h3 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h3><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。</p>
<p>这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。</p>
<p><strong>小结</strong></p>
<ul>
<li>搭建Git服务器非常简单，通常10分钟即可完成；</li>
<li></li>
<li>要方便管理公钥，用Gitosis；</li>
<li></li>
<li>要像SVN那样变态地控制权限，用Gitolite。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git教程学习-标签管理]]></title>
      <url>hubaoquan.github.io/2017/01/23/Git/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<pre><code>$ git branch
* dev
  master
$ git checkout master
Switched to branch &apos;master&apos;
</code></pre><p>然后，敲命令git tag <name>就可以打一个新标签：<br><a id="more"></a></name></p>
<pre><code>$ git tag v1.0
</code></pre><p>可以用命令git tag查看所有标签：</p>
<pre><code>$ git tag
v1.0
</code></pre><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<pre><code>$ git log --pretty=oneline --abbrev-commit
6a5819e merged bug fix 101
cc17032 fix bug 101
7825a50 merge with no-ff
6224937 add merge
59bc1cb conflict fixed
400b400 &amp; simple
75a857c AND simple
fec145a branch test
d17efd8 remove test.txt
...
</code></pre><p>比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：<br>    $ git tag v0.9 6224937<br>再用命令git tag查看标签：</p>
<pre><code>$ git tag
v0.9
v1.0
</code></pre><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：</tagname></p>
<pre><code>$ git show v0.9
commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Thu Aug 22 11:22:08 2013 +0800

add merge
...
</code></pre><p>可以看到，v0.9确实打在add merge这次提交上。</p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>
<pre><code>$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164
</code></pre><p>用命令git show <tagname>可以看到说明文字：</tagname></p>
<pre><code>$ git show v0.1
tag v0.1
Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Mon Aug 26 07:28:11 2013 +0800

version 0.1 released

commit 3628164fb26d48395383f8f31179f24e0882e1e0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Tue Aug 20 15:11:49 2013 +0800

append GPL
</code></pre><p>还可以通过-s用私钥签名一个标签：</p>
<pre><code>$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a
</code></pre><p>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：</p>
<pre><code>gpg: signing failed: secret key not available
error: gpg failed to sign the data
error: unable to sign the tag
</code></pre><p>如果报错，请参考GnuPG帮助文档配置Key。</p>
<p>用命令git show <tagname>可以看到PGP签名信息：</tagname></p>
<pre><code>$ git show v0.2
tag v0.2
Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Mon Aug 26 07:28:33 2013 +0800

signed version 0.2 released
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.12 (Darwin)

iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...
-----END PGP SIGNATURE-----

commit fec145accd63cdc9ed95a2f557ea0658a2a6537f
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Thu Aug 22 10:37:30 2013 +0800

branch test
</code></pre><p>用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。<br><strong>小结</strong></p>
<ul>
<li>命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</name></li>
<li></li>
<li>git tag -a <tagname> -m “blablabla…”可以指定标签信息；</tagname></li>
<li></li>
<li>git tag -s <tagname> -m “blablabla…”可以用PGP签名标签；</tagname></li>
<li></li>
<li>命令git tag可以查看所有标签。</li>
</ul>
<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>如果标签打错了，也可以删除：</p>
<pre><code>$ git tag -d v0.1
Deleted tag &apos;v0.1&apos; (was e078af9)
</code></pre><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</tagname></p>
<pre><code>$ git push origin v1.0
Total 0 (delta 0), reused 0 (delta 0)
To git@github.com:michaelliao/learngit.git
 * [new tag] v1.0 -&gt; v1.0
</code></pre><p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<pre><code>$ git push origin --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 554 bytes, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:michaelliao/learngit.git
 * [new tag] v0.2 -&gt; v0.2
 * [new tag] v0.9 -&gt; v0.9
</code></pre><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<pre><code>$ git tag -d v0.9
Deleted tag &apos;v0.9&apos; (was 6224937)
</code></pre><p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<pre><code>$ git push origin :refs/tags/v0.9
To git@github.com:michaelliao/learngit.git
 - [deleted] v0.9
</code></pre><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。<br><strong>小结</strong></p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li></li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li></li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li></li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git教程学习-分支管理]]></title>
      <url>hubaoquan.github.io/2017/01/23/Git/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="分支介绍"><a href="#分支介绍" class="headerlink" title="分支介绍"></a>分支介绍</h2><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。<br><a id="more"></a><br>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br><img src="/picture/git/branch.png" alt=""><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长.</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><img src="/picture/git/branch2.png" alt=""></p>
<p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><img src="/picture/git/branch3.png" alt=""></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br><img src="/picture/git/branch4.png" alt=""><br>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：<br><img src="/picture/git/branch5.png" alt=""></p>
<p><strong>下面开始实战</strong></p>
<p>首先，我们创建dev分支，然后切换到dev分支：</p>
<pre><code>$ git checkout -b dev
Switched to a new branch &apos;dev&apos;
</code></pre><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>
<pre><code>$ git branch dev
$ git checkout dev
Switched to branch &apos;dev&apos;
</code></pre><p>然后，用git branch命令查看当前分支：</p>
<pre><code>$ git branch
* dev
  master
</code></pre><p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p>
<p>Creating a new branch is quick.<br>然后提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;branch test&quot;
[dev fec145a] branch test
 1 file changed, 1 insertion(+)
</code></pre><p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>
<pre><code>$ git checkout master
Switched to branch &apos;master&apos;
</code></pre><p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：<br><img src="/picture/git/branch6.png" alt=""><br>现在，我们把dev分支的工作成果合并到master分支上：</p>
<pre><code>$ git merge dev
Updating d17efd8..fec145a
Fast-forward
 readme.txt |1 +
 1 file changed, 1 insertion(+)
</code></pre><p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除dev分支了：</p>
<pre><code>$ git branch -d dev
Deleted branch dev (was fec145a).
</code></pre><p>删除后，查看branch，就只剩下master分支了：</p>
<pre><code>$ git branch
* master
</code></pre><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>
<p><strong>小结</strong></p>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：git branch</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name></name></p>
<p>创建+切换分支：git checkout -b <name></name></p>
<p>合并某分支到当前分支：git merge <name></name></p>
<p>删除分支：git branch -d <name></name></p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>准备新的feature1分支，继续我们的新分支开发：</p>
<pre><code>$ git checkout -b feature1
Switched to a new branch &apos;feature1&apos;
</code></pre><p>修改readme.txt最后一行，改为：</p>
<p>Creating a new branch is quick AND simple.<br>在feature1分支上提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;AND simple&quot;
[feature1 75a857c] AND simple
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><p>切换到master分支：</p>
<pre><code>$ git checkout master
Switched to branch &apos;master&apos;
Your branch is ahead of &apos;origin/master&apos; by 1 commit.
</code></pre><p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>
<p>在master分支上把readme.txt文件的最后一行改为：</p>
<p>Creating a new branch is quick &amp; simple.<br>提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;&amp; simple&quot;
[master 400b400] &amp; simple
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><p>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：<br><img src="/picture/git/branch7.png" alt=""></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<pre><code>$ git merge feature1
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.
</code></pre><p>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：</p>
<pre><code>$ git status
# On branch master
# Your branch is ahead of &apos;origin/master&apos; by 2 commits.
#
# Unmerged paths:
#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)
#
#   both modified:  readme.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>我们可以直接查看readme.txt的内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
</code></pre><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：</p>
<p>Creating a new branch is quick and simple.<br>再提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;conflict fixed&quot;
[master 59bc1cb] conflict fixed
</code></pre><p>现在，master分支和feature1分支变成了下图所示：<br><img src="/picture/git/branch.png" alt=""></p>
<p>用带参数的git log也可以看到分支的合并情况：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
*   59bc1cb conflict fixed
|\
| * 75a857c AND simple
* | 400b400 &amp; simple
|/
* fec145a branch test
...
</code></pre><p>最后，删除feature1分支：</p>
<pre><code>$ git branch -d feature1
Deleted branch feature1 (was 75a857c).
</code></pre><p>工作完成。</p>
<p><strong>小结</strong></p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>用git log –graph命令可以看到分支合并图。</p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p><strong>分支策略</strong></p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：<br>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；<br>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。<br>所以，团队合作的分支看起来就像这样：<br><img src="/picture/git/branch9.png" alt=""></p>
<p><strong>小结</strong></p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<br>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p>
<pre><code>$ git status
# On branch dev
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#   new file:   hello.py
#
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#   modified:   readme.txt
#
</code></pre><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<pre><code>$ git stash
Saved working directory and index state WIP on dev: 6224937 add merge
HEAD is now at 6224937 add merge
</code></pre><p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p>
<pre><code>$ git checkout master
Switched to branch &apos;master&apos;
Your branch is ahead of &apos;origin/master&apos; by 6 commits.
$ git checkout -b issue-101
Switched to a new branch &apos;issue-101&apos;
</code></pre><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;fix bug 101&quot;
[issue-101 cc17032] fix bug 101
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p>
<pre><code>$ git checkout master
Switched to branch &apos;master&apos;
Your branch is ahead of &apos;origin/master&apos; by 2 commits.
$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101
Merge made by the &apos;recursive&apos; strategy.
 readme.txt |2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git branch -d issue-101
Deleted branch issue-101 (was cc17032).
</code></pre><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p>
<pre><code>$ git checkout dev
Switched to branch &apos;dev&apos;
$ git status
# On branch dev
nothing to commit (working directory clean)
</code></pre><p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p>
<pre><code>$ git stash list
stash@{0}: WIP on dev: 6224937 add merge
</code></pre><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p>
<pre><code>$ git stash pop
# On branch dev
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#   new file:   hello.py
#
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#   modified:   readme.txt
#
</code></pre><p>Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)<br>再用git stash list查看，就看不到任何stash内容了：</p>
<pre><code>$ git stash list
</code></pre><p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p>
<pre><code>$ git stash apply stash@{0}
</code></pre><p><strong>小结</strong></p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发：</p>
<pre><code>$ git checkout -b feature-vulcan
Switched to a new branch &apos;feature-vulcan&apos;
</code></pre><p>5分钟后，开发完毕：</p>
<pre><code>$ git add vulcan.py
$ git status
# On branch feature-vulcan
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#   new file:   vulcan.py
#
$ git commit -m &quot;add feature vulcan&quot;
[feature-vulcan 756d4af] add feature vulcan
 1 file changed, 2 insertions(+)
 create mode 100644 vulcan.py
</code></pre><p>切回dev，准备合并：</p>
<pre><code>$ git checkout dev
</code></pre><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>但是，</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p>
<p>虽然白干了，但是这个分支还是必须就地销毁：</p>
<pre><code>$ git branch -d feature-vulcan
error: The branch &apos;feature-vulcan&apos; is not fully merged.
If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.
</code></pre><p>销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</p>
<p>现在我们强行删除：</p>
<pre><code>$ git branch -D feature-vulcan
Deleted branch feature-vulcan (was 756d4af).
</code></pre><p>终于删除成功！</p>
<p><strong>小结</strong></p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用git remote：</p>
<pre><code>$ git remote
origin
</code></pre><p>或者，用git remote -v显示更详细的信息：</p>
<pre><code>$ git remote -v
origin  git@github.com:michaelliao/learngit.git (fetch)
origin  git@github.com:michaelliao/learngit.git (push)
</code></pre><p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<pre><code>$ git push origin master
</code></pre><p>如果要推送其他分支，比如dev，就改成：</p>
<pre><code>$ git push origin dev
</code></pre><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<p>master分支是主分支，因此要时刻与远程同步；</p>
<p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<pre><code>$ git clone git@github.com:michaelliao/learngit.git
</code></pre><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：</p>
<pre><code>$ git branch
* master
</code></pre><p>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：</p>
<pre><code>$ git checkout -b dev origin/dev
</code></pre><p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：</p>
<pre><code>$ git commit -m &quot;add /usr/bin/env&quot;
[dev 291bea8] add /usr/bin/env
 1 file changed, 1 insertion(+)
$ git push origin dev
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 349 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:michaelliao/learngit.git
   fc38031..291bea8  dev -&gt; dev
</code></pre><p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<pre><code>$ git add hello.py 
$ git commit -m &quot;add coding: utf-8&quot;
[dev bd6ae48] add coding: utf-8
 1 file changed, 1 insertion(+)
$ git push origin dev
To git@github.com:michaelliao/learngit.git
 ! [rejected]        dev -&gt; dev (non-fast-forward)
error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)
hint: before pushing again.
hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.
</code></pre><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：</p>
<pre><code>$ git pull
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From github.com:michaelliao/learngit
   fc38031..291bea8  dev        -&gt; origin/dev
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream dev origin/&lt;branch&gt;
</code></pre><p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p>
<pre><code>$ git branch --set-upstream dev origin/dev
Branch dev set up to track remote branch dev from origin.
再pull：

$ git pull
Auto-merging hello.py
CONFLICT (content): Merge conflict in hello.py
Automatic merge failed; fix conflicts and then commit the result.
</code></pre><p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>
<pre><code>$ git commit -m &quot;merge &amp; fix hello.py&quot;
[dev adca45d] merge &amp; fix hello.py
$ git push origin dev
Counting objects: 10, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (6/6), 747 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)
To git@github.com:michaelliao/learngit.git
   291bea8..adca45d  dev -&gt; dev
</code></pre><p>多人协作</p>
<p>阅读: 352360<br>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用git remote：</p>
<p>$ git remote<br>origin<br>或者，用git remote -v显示更详细的信息：</p>
<p>$ git remote -v<br>origin  git@github.com:michaelliao/learngit.git (fetch)<br>origin  git@github.com:michaelliao/learngit.git (push)<br>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<p>推送分支</p>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<p>$ git push origin master<br>如果要推送其他分支，比如dev，就改成：</p>
<p>$ git push origin dev<br>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<p>master分支是主分支，因此要时刻与远程同步；</p>
<p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<p>0:00</p>
<p>抓取分支</p>
<p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<p>$ git clone git@github.com:michaelliao/learngit.git<br>Cloning into ‘learngit’…<br>remote: Counting objects: 46, done.<br>remote: Compressing objects: 100% (26/26), done.<br>remote: Total 46 (delta 16), reused 45 (delta 15)<br>Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.<br>Resolving deltas: 100% (16/16), done.<br>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：</p>
<p>$ git branch</p>
<ul>
<li>master<br>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：</li>
</ul>
<p>$ git checkout -b dev origin/dev<br>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：</p>
<p>$ git commit -m “add /usr/bin/env”<br>[dev 291bea8] add /usr/bin/env<br> 1 file changed, 1 insertion(+)<br>$ git push origin dev<br>Counting objects: 5, done.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (2/2), done.<br>Writing objects: 100% (3/3), 349 bytes, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>To git@github.com:michaelliao/learngit.git<br>   fc38031..291bea8  dev -&gt; dev</p>
<p>0:00</p>
<p> 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<p>$ git add hello.py<br>$ git commit -m “add coding: utf-8”<br>[dev bd6ae48] add coding: utf-8<br> 1 file changed, 1 insertion(+)<br>$ git push origin dev<br>To git@github.com:michaelliao/learngit.git<br> ! [rejected]        dev -&gt; dev (non-fast-forward)<br>error: failed to push some refs to ‘git@github.com:michaelliao/learngit.git’<br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Merge the remote changes (e.g. ‘git pull’)<br>hint: before pushing again.<br>hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details.<br>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：</p>
<p>$ git pull<br>remote: Counting objects: 5, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 3 (delta 0)<br>Unpacking objects: 100% (3/3), done.<br>From github.com:michaelliao/learngit<br>   fc38031..291bea8  dev        -&gt; origin/dev<br>There is no tracking information for the current branch.<br>Please specify which branch you want to merge with.<br>See git-pull(1) for details</p>
<pre><code>git pull &lt;remote&gt; &lt;branch&gt;
</code></pre><p>If you wish to set tracking information for this branch you can do so with:</p>
<pre><code>git branch --set-upstream dev origin/&lt;branch&gt;
</code></pre><p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p>
<p>$ git branch –set-upstream dev origin/dev<br>Branch dev set up to track remote branch dev from origin.<br>再pull：</p>
<p>$ git pull<br>Auto-merging hello.py<br>CONFLICT (content): Merge conflict in hello.py<br>Automatic merge failed; fix conflicts and then commit the result.<br>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>
<p>$ git commit -m “merge &amp; fix hello.py”<br>[dev adca45d] merge &amp; fix hello.py<br>$ git push origin dev<br>Counting objects: 10, done.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (5/5), done.<br>Writing objects: 100% (6/6), 747 bytes, done.<br>Total 6 (delta 0), reused 0 (delta 0)<br>To git@github.com:michaelliao/learngit.git<br>   291bea8..adca45d  dev -&gt; dev</p>
<p>0:00</p>
<p> 因此，多人协作的工作模式通常是这样：</p>
<p>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</p>
<p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name。</code></p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><strong>小结</strong></p>
<p>查看远程库信息，使用<code>git remote -v；</code></p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name；</code></p>
<p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git教程学习-远程仓库]]></title>
      <url>hubaoquan.github.io/2017/01/23/Git/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<p>$ ssh-keygen -t rsa -C “youremail@example.com”<br>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br><a id="more"></a><br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。点“Add Key”，你就应该看到已经添加的Key。</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>
<p>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：</p>
<pre><code>$ git remote add origin git@github.com:远程库地址
</code></pre><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：   </p>
<pre><code>$ git push -u origin master
</code></pre><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<pre><code>$ git push origin master
</code></pre><p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<p><strong>小结</strong></p>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git；</code></p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。" target="_blank" rel="external">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<p>小结</p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br>    git clone git@server-name:path/repo-name.git<br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git教程学习-文件版本控制]]></title>
      <url>hubaoquan.github.io/2017/01/17/Git/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="状态查看命令"><a href="#状态查看命令" class="headerlink" title="状态查看命令"></a>状态查看命令</h2><pre><code>git status  
</code></pre><p>可以查看当前版本库的状态，可以告诉你哪些文件被修改。<br>如果想查看被修改的文件内容，使用 <code>git diff</code> 命令。<br>    例如：git diff readme.txt<br>要随时掌握工作区的状态，使用git status命令。<br>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。<br><a id="more"></a></p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：     </p>
<pre><code>$ git log
commit 82ef6f6b7e967f1217b27d812a794327b1e36457
Author: HuBaoquan &lt;hubaoquan1994@gmail.com&gt;
Date:   Tue Jan 17 14:25:14 2017 +0800
Modfiy readme.txt
commit 73fac6fa094236620b11de5372e8e3fdaf45f6e7
Author: HuBaoquan &lt;hubaoquan1994@gmail.com&gt;
Date:   Tue Jan 17 14:19:29 2017 +0800
Create readme.txt
</code></pre><p>git log命令可以查看我们以前提交的版本，但是这么多信息，看的人眼花缭乱，可以添加一条参数：<code>--pretty=online</code></p>
<pre><code>$ git log --pretty=oneline
82ef6f6b7e967f1217b27d812a794327b1e36457 Modfiy readme.txt
73fac6fa094236620b11de5372e8e3fdaf45f6e7 Create readme.txt
</code></pre><p>这里显示的信息，前边是版本号后边是commit时-m 后的信息。</p>
<p>现在我们如果想找回以前的版本该怎么做呢？<br>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交82ef6f6b7e967f1217b27d812a794327b1e36457（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。<br>现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at ea34578 add distributed
</code></pre><p>根据提交号恢复：<br>    git reset –hard commit_id  </p>
<font color="#ff0033" size="3" face="微软雅黑" style="font-weight:bold;font-style:italic;">注意提交号比较长可以不用写完，因为git会自动去找到完整提交号，所以写前几位就行了<br><br>如果找不到提交号，可以用git reflog 命令查看命令历史</font>  

<p><strong>小结</strong></p>
<p>现在总结一下：</p>
<p>总之只要知道提交号就可以回到提交之后的版本。</p>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p>
<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>工作区（Working Directory）</p>
<p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：<br>  <img src="/picture/git/learngit.png" alt=""><br>版本库（Repository）</p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="/picture/git/repository.jpg" alt=""><br>前边讲将文件添加到版本库的时候，实际上是分两步：  </p>
<ol>
<li>用<code>git add</code>命令将文件添加进去，实际上就是把修改文件放进暂存区；  </li>
<li>用<code>git commit</code>命令提交修改，实际上就是把暂存区的内容提交到当前分支</li>
</ol>
<p>当执行<code>git commit</code>后，如果工作区的文件没有做任何修改，这时候查看状态是没有可以提交的内容。</p>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>Git之所以比其他版本控制软件优秀的原因是因为git管理的是修改，而不是文件，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。  </p>
<p>如果你修改了文件但是没有提交，git是不会记录你的修改的。</p>
<p><font color="#00ff99" size="4" face="微软雅黑" style="font-weight:bold;font-style:italic;">注意：</font><br>如果修改了而没有add到暂存区，提交也是没用的，commit是提交暂存区的文件到版本库。</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ol>
<li>git checkout – file可以丢弃工作区的修改</li>
</ol>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p>
<ol>
<li>用命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区： <code>git reset HEAD readme.txt</code></li>
</ol>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>
<p><strong>小结</strong></p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。  </p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p>
<pre><code>$ git add test.txt
$ git commit -m &quot;add test.txt&quot;
[master 94cdc44] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
</code></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<pre><code>$ rm test.txt
</code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
<pre><code>$ git status
# On branch master
# Changes not staged for commit:
#   (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#   deleted:test.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p>
<pre><code>$ git rm test.txt
rm &apos;test.txt&apos;
$ git commit -m &quot;remove test.txt&quot;
[master d17efd8] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre><p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<pre><code>$ git checkout -- test.txt
</code></pre><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>小结</p>
<p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git教程学习-创建版本库]]></title>
      <url>hubaoquan.github.io/2017/01/17/Git/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="Git用户信息配置"><a href="#Git用户信息配置" class="headerlink" title="Git用户信息配置"></a>Git用户信息配置</h2><pre><code>$ git config --global user.name &quot;Your Name&quot;   配置用户名
$ git config --global user.email &quot;email@example.com&quot;  配置用户邮箱
</code></pre><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>　　版本库：版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：<br>　　以我的机器Windows平台来说，先建立一个不含中文路径的文件夹：<br>　　然后在该文件夹下运行命令: <code>git init</code><br>　　瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br><a id="more"></a></p>
<h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>　　首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。<br>　　不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。<br>　　因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。  </p>
<p><font color="#993300" size="3" face="微软雅黑" style="font-weight:bold;">使用Windows的童鞋要特别注意：</font><br>　　千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载其他文本编辑软件，记得把默认编码设置为UTF-8即可：<br>言归正传，现在我们编写一个readme.txt文件，内容如下：<br>Git is a version control system.<br>Git is free software.<br>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。<br>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。<br>第一步，用命令git add告诉Git，把文件添加到仓库：<br>    <code>$ git add readme.txt</code><br>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。<br>第二步，用命令git commit告诉Git，把文件提交到仓库：<br><code>$ git commit -m &quot;wrote a  readme file&quot;</code><br>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p>git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m &quot;add 3 files.&quot;
</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在总结一下今天学的两点内容：</p>
<p>初始化一个Git仓库，使用git init命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<p>第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></p>
<p>第二步，使用命令git commit，完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AndroidStudio的使用]]></title>
      <url>hubaoquan.github.io/2016/12/26/Android/AndroidStudio%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<ol>
<li>打印Log的快捷方式  </li>
</ol>
<ul>
<li>快速生成TAG: <code>logt</code>  TAG内容为当前类名  </li>
<li>输出log：<code>logd</code>    </li>
<li>打印输出参数：<code>logm</code>  会打印输出函数的参数</li>
<li>打印error: <code>loge</code>  </li>
</ul>
<a id="more"></a>
<p>2.代码移动：选中后【Ctrl + Shift + ↑/↓】支持多行移动<br>3.复制当前行到下一行：【Ctrl+D】支持选中多行<br>4.删除代码：【Ctrl+Y】支持删除多行<br>5.浏览类中方法：【Alt+↑/↓】  </p>
<ol>
<li>查找已经创建的类：【Ctrl+N】  </li>
<li>查找存在的xml文件:【Ctrl+Shift+N】  </li>
<li>查看变量声明：【Ctrl+B】或【Ctrl+鼠】标左键  </li>
<li>查看一个类的父类：【Ctrl+U】  </li>
<li>查看一个方法的调用：【Ctrl+Alt+H】  </li>
<li>在类中查看一个方法的定义：选择方法名然后【Ctrl+Shift+i】  </li>
<li>显示类的层级：【Ctrl + H】</li>
<li>窗口切换：【Alt+ ←/→】</li>
<li>代码块折叠展开：【Ctrl+ +/-】</li>
<li>隐藏工程面板：【Alt+1】</li>
<li>查找类中变量或方法：【Ctrl+Shift+Alt+N】</li>
<li>显示当前文件结构：【Ctrl+F12】</li>
<li>查看/复写父类的方法: 【Ctrl+O】 </li>
<li>跳转到大括号开始和结尾【Ctrl+ [ ]】  </li>
<li>用【Ctrl+j】可以查看一些自动代码生成快捷方法。  </li>
<li>格式化代码【Ctrl+Alt+L】  </li>
<li>打开最近打开过的文件【Ctrl+E】  </li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文章摘录]]></title>
      <url>hubaoquan.github.io/2016/12/26/Notes/%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95/</url>
      <content type="html"><![CDATA[<div id="myTime"><object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0" width="160" height="70" id="honehoneclock" align="middle"><param name="allowScriptAccess" value="always"><param name="movie" value="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.swf"><param name="quality" value="high"><param name="bgcolor" value="#ffffff"><param name="wmode" value="transparent"><embed wmode="transparent" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.swf" quality="high" bgcolor="#ffffff" width="160" height="70" name="honehoneclock" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"></object></div>  

<ol>
<li><font color="#cc3300" size="4" face="微软雅黑" style="font-weight:bold;">越是猥琐无能之辈，越爱做道德的评判师，越爱用指责和爆料，来展示自己的“神勇”和“牛逼”，隐藏自己的自私、懦弱和无能。其实，你不是牛逼是傻逼。  —《真爱过，会沉默》李爱玲 </font>  </li>
<li><font color="#993366" size="4" face="微软雅黑" style="font-weight:bold;">对别人负责，更对自己负责，让别人舒服，更让自己舒服，这才叫情商高。—李月亮</font>  


</li>
</ol>
<p><img src="\picture\Notes\missmio-Page22-10.jpg" alt=""><br><a id="more"></a></p>
<ol>
<li><font color="#00cccc" size="4" face="微软雅黑" style="font-weight:bold;font-style:italic;">在感情的世界里最怕的莫过于，我抱定了和你一辈子的决心，而你却对我处处设防。别用金钱去考验爱情，因为你出不起那个价码。—-《舍不得给你花钱的人，更不会舍得给你爱》方不见</font>  </li>
<li></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>hubaoquan.github.io/2016/12/25/Java/1Java%E5%9F%BA%E7%A1%80/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android简介]]></title>
      <url>hubaoquan.github.io/2016/12/25/Android/01Android%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java简单复习]]></title>
      <url>hubaoquan.github.io/2016/12/17/Java/Java%E7%AE%80%E5%8D%95%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<div id="myTime"><object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0" width="160" height="70" id="honehoneclock" align="middle"><param name="allowScriptAccess" value="always"><param name="movie" value="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.swf"><param name="quality" value="high"><param name="bgcolor" value="#ffffff"><param name="wmode" value="transparent"><embed wmode="transparent" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.swf" quality="high" bgcolor="#ffffff" width="160" height="70" name="honehoneclock" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"></object></div>  

<h2 id="1-JVM"><a href="#1-JVM" class="headerlink" title="1.JVM"></a>1.JVM</h2><p> 　　Java 虚拟机 Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM实现了Java语言最重要的特征：即平台无关性。原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class）,就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证，同时也是 Java 程序的安全检验引擎（还进行安全检查）。<br><a id="more"></a><br>　　  JVM 是 编译后的 Java 程序（.class文件）和硬件系统之间的接口 （ 编译后：javac 是收录于 JDK 中的 Java 语言编译器。该工具可以将后缀名为. java 的源文件编译为后缀名为. class 的可以运行于 Java 虚拟机的字节码。）  </p>
<h2 id="2-Java版本"><a href="#2-Java版本" class="headerlink" title="2.Java版本"></a>2.Java版本</h2><p>　　<strong>Java  ME：</strong>Java ME以往称作J2ME（Java Platform, Micro Edition）是为机顶盒、移动电话和PDA之类嵌入式消费电子设备提供的Java语言平台，包括虚拟机和一系列标准化的Java API。它和Java SE、Java EE一起构成Java技术的三大版本，并且同样是通过JCP（Java Community Process）制订的。<br>　　<strong>Java  SE：</strong>J2SE，标准版的Java平台是一个Java2的平台，为用户提供一个程序开发环境。这个程序开发环境提供了开发与运行Java软件的编译器等开发工具、软件库及Java虚拟机。它也是Java2平台、企业版本和Java网页服务的基础。<br>　　<strong>Java  EE：</strong>Java EE，Java平台企业版（Java Platform Enterprise Edition），是Sun公司为企业级应用推出的标准平台。Java平台共分为三个主要版本Java EE、Java SE和Java ME。<br>Sun公司在1998年发表JDK1.2版本的时候，使用了新名称Java 2 Platform，即“Java2平台”，修改后的JDK称为Java 2 Platform Software Developing Kit，即J2SDK。并分为标准版（Standard Edition，J2SE），企业版（Enterprise Edition，J2EE），微型版（MicroEdition，J2ME）。J2EE便由此诞生。<br>　　2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字“2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。随着Java技术的发展，J2EE平台得到了迅速的发展，成为Java语言中最活跃的体系之一。现如今，J2EE不仅仅是指一种标准平台，它更多的表达着一种软件架构和设计思想。  </p>
<h2 id="3-Java标识符命名规则与规范"><a href="#3-Java标识符命名规则与规范" class="headerlink" title="3.Java标识符命名规则与规范"></a>3.Java标识符命名规则与规范</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a><strong>规则</strong></h3><ol>
<li>标识符由大小写字母, 下划线, 数字, $符号组成.</li>
<li>开头可以是大小写字母, 下划线, 和$符号(数字和其他符号不能开头)</li>
<li>标识符长度没有限制</li>
<li>标识符不能是关键子和保留字</li>
</ol>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a><strong>规范</strong></h3><ol>
<li>标识符的命名最好能反映出其作用</li>
<li>java语言对字母的大小写有严格的要求</li>
<li>所有自定义标识符需全部遵循标识符的命名规范  </li>
</ol>
<pre><code>变量
</code></pre><ol>
<li>如果是单个单词, 单词全部字母小写. 如:<code>int count</code>;</li>
<li>如果是由多个单词组成的复合单词, 除第一个单词外,  其后所有单词首字母大写. 如: <code>int sumScore</code>;  </li>
</ol>
<pre><code>常量
</code></pre><ol>
<li>常量所有单词字母大写, 如果是由多个单词组成, 由下划线连接.如: <code>String PERSON_NAME</code>;  </li>
</ol>
<pre><code>方法 
</code></pre><ol>
<li>方法命名规范与变量相似, 如 count(); getSum();  </li>
</ol>
<pre><code>类
</code></pre><ol>
<li>类名的所有单词首字母均大写. 如Person{}  , DataCenter{};  </li>
</ol>
<pre><code>包 
</code></pre><ol>
<li>用小写的倒置域名来命名. 格式: 前缀 + 项目名 + 模块名 + 层如: org.itfuture.domain.sorts  </li>
</ol>
<h2 id="4-Java关键词"><a href="#4-Java关键词" class="headerlink" title="4.Java关键词"></a>4.Java关键词</h2><p></p>
<p><table log-set-param="table_view" class="table-view log-set-param"><tr><td><b>关键字</b></td><td><b>含义</b></td></tr><tr><td>abstract</td><td>表明类或者成员方法具有抽象属性</td></tr><tr><td>assert</td><td>用来进行程序调试</td></tr><tr><td>boolean</td><td>基本数据类型之一，布尔类型</td></tr><tr><td>break</td><td>提前跳出一个块</td></tr><tr><td>byte</td><td>基本数据类型之一，字节类型</td></tr><tr><td>case</td><td>用在switch语句之中，表示其中的一个分支<br>　　</td></tr><tr><td>catch</td><td>用在异常处理中，用来捕捉异常</td></tr><tr><td>char</td><td>基本数据类型之一，字符类型</td></tr><tr><td>class</td><td>类</td></tr><tr><td>const</td><td>保留关键字，没有具体含义</td></tr><tr><td>continue</td><td>回到一个块的开始处</td></tr><tr><td>default</td><td>默认，例如，用在switch语句中，表明一个默认的分支</td></tr><tr><td>do</td><td>用在do-while循环结构中</td></tr><tr><td>double</td><td>基本数据类型之一，双精度浮点数类型</td></tr><tr><td>else</td><td>用在条件语句中，表明当条件不成立时的分支</td></tr><tr><td>enum</td><td>枚举</td></tr><tr><td>extends</td><td>表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</td></tr><tr><td>final</td><td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变</td></tr><tr><td>finally</td><td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td></tr><tr><td>float</td><td>基本数据类型之一，单精度浮点数类型</td></tr><tr><td>for</td><td>一种循环结构的引导词</td></tr><tr><td>goto</td><td>保留关键字，没有具体含义</td></tr><tr><td>if</td><td>条件语句的引导词</td></tr><tr><td>implements</td><td>表明一个类实现了给定的接口</td></tr><tr><td>import</td><td>表明要访问指定的类或包</td></tr><tr><td>instanceof</td><td>用来测试一个对象是否是指定类型的实例对象</td></tr><tr><td>int</td><td>基本数据类型之一，整数类型</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>long</td><td>基本数据类型之一，长整数类型</td></tr><tr><td>native</td><td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td></tr><tr><td>new</td><td>用来创建新实例对象</td></tr><tr><td colspan="1" rowspan="1">null</td><td colspan="1" rowspan="1">用来标识一个不确定的对象</td></tr><tr><td>package</td><td>包</td></tr><tr><td>private</td><td>一种访问控制方式：私用模式</td></tr><tr><td>protected</td><td>一种访问控制方式：保护模式</td></tr><tr><td>public</td><td>一种访问控制方式：共用模式</td></tr><tr><td>return</td><td>从成员方法中返回数据</td></tr><tr><td>short</td><td>基本数据类型之一,短整数类型</td></tr><tr><td>static</td><td>表明具有静态属性</td></tr><tr><td>strictfp</td><td>用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</td></tr><tr><td>super</td><td>表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td>switch</td><td>分支语句结构的引导词</td></tr><tr><td>synchronized</td><td>表明一段代码需要同步执行</td></tr><tr><td>this</td><td>指向当前实例对象的引用</td></tr><tr><td>throw</td><td>抛出一个异常</td></tr><tr><td>throws</td><td>声明在当前定义的成员方法中所有需要抛出的异常</td></tr><tr><td>transient</td><td>声明不用序列化的成员域</td></tr><tr><td>try</td><td>尝试一个可能抛出异常的程序块</td></tr><tr><td>void</td><td>声明当前成员方法没有返回值</td></tr><tr><td>volatile<br>　　</td><td>表明两个或者多个变量必须同步地发生变化</td></tr><tr><td colspan="1" rowspan="1">while<br>　　</td><td colspan="1" rowspan="1">用在循环结构中 <br>　　</td></tr></table><div class="anchor-list">  </div></p>
<h2 id="5-数据类型与所占字节"><a href="#5-数据类型与所占字节" class="headerlink" title="5.数据类型与所占字节"></a>5.数据类型与所占字节</h2><p>　　Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下：  </p>
<pre><code>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。
short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。
int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。
long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。
float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。
double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。  
boolean：只有true和false两个取值。
char：16位，存储Unicode码，用单引号赋值。  
</code></pre><p><div>表2<div><table><tbody><tr><td valign="top">类型</td><td valign="top">字节</td><td valign="top">表示范围</td><td valign="top">包装类</td></tr><tr><td valign="top">byte(字节型)</td><td valign="top">1</td><td valign="top">-128~127</td><td valign="top">Byte</td></tr><tr><td valign="top">short(短整型)</td><td valign="top">2</td><td valign="top">-32768～32767&nbsp;</td><td valign="top">Short</td></tr><tr><td valign="top">int(整型)</td><td valign="top">4</td><td valign="top">-2147483648～2147483647</td><td valign="top">Integer</td></tr><tr><td valign="top">long(长整型)</td><td valign="top">8</td><td valign="top">-9223372036854775808 ~ 9223372036854775807</td><td valign="top">Long</td></tr><tr><td valign="top">float(浮点型)</td><td valign="top">4</td><td valign="top">-3.4E38～3.4E38</td><td valign="top">Float</td></tr><tr><td valign="top">double(双精度型)</td><td valign="top">8</td><td valign="top">-1.7E308～1.7E308</td><td valign="top">Double</td></tr><tr><td valign="top">char(字符型)</td><td valign="top">2</td><td valign="top">从字符型对应的整型数来划分，其表示范围是0～65535&nbsp;</td><td valign="top">Charater</td></tr><tr><td valign="top">booealn(布尔型)</td><td valign="top">1</td><td valign="top">true或false</td><td valign="top">Boolean</td></tr></tbody></table></div></div></p>
<h2 id="6-常量和变量的表示"><a href="#6-常量和变量的表示" class="headerlink" title="6.常量和变量的表示"></a>6.常量和变量的表示</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><font color="#0066ff" size="5" face="微软雅黑" style="font-weight:bold;font-style:italic;">常量</font></h3><p>　　常量代表程序运行过程中不能改变的值。<br>　　常量在程序运行过程中主要有2个作用：<br>　　　　1. 代表常数，便于程序的修改（例如：圆周率的值）<br>　　　　2. 增强程序的可读性（例如：常量UP、DOWN、LEFT和RIGHT分辨代表上下左右，其数值分别是1、2、3和4）<br>　　常量的语法格式和变量类型，只需要在变量的语法格式前面添加关键字final即可。在Java编码规范中，要求常量名必须大写。<br>　　则常量的语法格式如下：<br>　　　　final 数据类型 常量名称 = 值；<br>　　　　final 数据类型 常量名称1 = 值1， 常量名称2 = 值2，……常量名称n = 值n；<br>　　例如：  </p>
<pre><code>final double PI = 3.14；  
final char MALE=‘M’，FEMALE=‘F’；  
</code></pre><p>在Java语法中，常量也可以首先声明，然后再进行赋值，但是只能赋值一次，示例代码如下：  </p>
<pre><code>final int UP；  
UP = 1；
</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><font color="#00ff99" size="5" face="微软雅黑" style="font-weight:bold;">注意：</font></h3><p>　　成员变量会被系统默认初始化，局部变量没这功能，所以必须自己初始化。<br>还要注意静态成员变量也没系统默认初始化，必须在初始化块或者定义时或者构造函数里进行手动初始化。  </p>
<h2 id="7-类型转换的特殊形式"><a href="#7-类型转换的特殊形式" class="headerlink" title="7.类型转换的特殊形式"></a>7.类型转换的特殊形式</h2><p><a href="http://www.jb51.net/article/85533.htm" target="_blank" rel="external">Java类型转换</a>  </p>
<h2 id="8-Math类常用方法"><a href="#8-Math类常用方法" class="headerlink" title="8.Math类常用方法"></a>8.Math类常用方法</h2><ol>
<li>static double <strong>random</strong>() 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 </li>
<li>static long <strong>round</strong>(double a) 返回最接近参数的 long。</li>
<li>abs 返回绝对值</li>
</ol>
<h2 id="9-使用Scanner类注意方式引入的包"><a href="#9-使用Scanner类注意方式引入的包" class="headerlink" title="9.使用Scanner类注意方式引入的包"></a>9.使用Scanner类注意方式引入的包</h2><pre><code>import java.util.Scanner;  
Scanner scanner = new Scanner(System.in);
</code></pre><h2 id="10-Break、continue、Return"><a href="#10-Break、continue、Return" class="headerlink" title="10.Break、continue、Return"></a>10.Break、continue、Return</h2><ol>
<li>break:跳出当前的循环，如果是嵌套只跳出本层</li>
<li>continue:跳过本次进行下次循环</li>
<li>return：结束函数</li>
</ol>
<h2 id="11-类的结构"><a href="#11-类的结构" class="headerlink" title="11.类的结构"></a>11.类的结构</h2><pre><code>public class className{
      //全局变量
   public static void main(String[] args) {
      //局部变量
      //函数体
  }
  //函数
  private int fun(){
    return 1;
  }
}
</code></pre><h2 id="12-对象的创建和初始化"><a href="#12-对象的创建和初始化" class="headerlink" title="12.对象的创建和初始化"></a>12.对象的创建和初始化</h2><pre><code>类名 变量名 = new 类构造函数();
类名 变量名1；
变量名1 = new 类构造函数();
</code></pre><h2 id="13-静态初始化块与非静态初始化块"><a href="#13-静态初始化块与非静态初始化块" class="headerlink" title="13.静态初始化块与非静态初始化块"></a>13.静态初始化块与非静态初始化块</h2><p>　　静态初始化块:使用static定义,当类装载到系统时执行一次.若在静态初始化块中想初始化变量,那仅能初始化类变量,即static修饰的数据成员.<br>　　非静态初始化块:在每个对象生成时都会被执行一次,可以初始化类的实例变量.<br>　　非静态初始化块会在构造函数执行时,且在构造函数主体代码执行之前被运行.<br>括号里的是初始化块，这里面的代码在创建Java对象时执行，而且在构造器之前执行！<br>　　其实初始化块就是构造器的补充，初始化块是不能接收任何参数的，定义的一些所有对象共有的属性、方法等内容时就可以用初始化块了初始化！！<br>　　好处是可以提高初始化块的复用，提高整个应用的可维护性。 </p>
<pre><code> public class TestInitiateBlock {

 {
   System.out.println(&quot;In non-static initialization block!&quot;);
 };

 static {
    System.out.println(&quot;In static initialization block!&quot;);
 };

 public TestInitiateBlock() {
   System.out.println(&quot;In Constructor1!&quot;);
 }

 public void show() {
    System.out.println(&quot;In show()!&quot;);
 }

 public static void main(String[] args) {
   TestInitiateBlock ti = new TestInitiateBlock();
   ti.show();
 }
}

运行结果:  
In static initialization block!  
In non-static initialization block!  
In Constructor1!  
In show()!  
</code></pre><h2 id="14-局部变量使用前，先初始化"><a href="#14-局部变量使用前，先初始化" class="headerlink" title="14.局部变量使用前，先初始化"></a>14.局部变量使用前，先初始化</h2><p>　　局部变量详相当于在学校的学号或者公司的工号，只有去了学校或公司才有。而全局变量相当于你的姓名，在出生时或出生之前就有了。</p>
<h2 id="15-适配器"><a href="#15-适配器" class="headerlink" title="15.适配器"></a>15.适配器</h2><p>　　Java中的适配器实际就是实现接口的类，只不过这个类中的方法都是空方法，当你需要使用哪个方法时，只需在方法种添加相应过程。</p>
<h2 id="16-Awt"><a href="#16-Awt" class="headerlink" title="16.Awt"></a>16.Awt</h2><p>　　AWT 是Abstract Window ToolKit (抽象窗口工具包)的缩写，这个工具包提供了一套与本地图形界面进行交互的接口。AWT 中的图形函数与操作系统所提供的图形函数之间有着一一对应的关系，我们把它称为peers。 也就是说，当我们利用 AWT 来构件图形用户界面的时候，我们实际上是在利用操作系统所提供的图形库。由于不同操作系统的图形库所提供的功能是不一样的，在一个平台上存在的功能在另外一个平台上则可能不存在。为了实现Java语言所宣称的”一次编译，到处运行”的概念，AWT 不得不通过牺牲功能来实现其平台无关性，也就是说，AWT 所提供的图形功能是各种通用型操作系统所提供的图形功能的交集。由于AWT 是依靠本地方法来实现其功能的，我们通常把AWT控件称为重量级控件。 </p>
<h2 id="17-Swing"><a href="#17-Swing" class="headerlink" title="17.Swing"></a>17.Swing</h2><p>　　Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充。例如说并不是所有的操作系统都提供了对树形控件的支持， Swing 利用了AWT 中所提供的基本作图方法对树形控件进行模拟。由于 Swing 控件是用100%的Java代码来实现的，因此在一个平台上设计的树形控件可以在其他平台上使用。由于在Swing 中没有使用本地方法来实现图形功能，我们通常把Swing控件称为轻量级控件。<br>　　AWT和Swing之间的基本区别：AWT 是基于本地方法的C/C++程序，其运行速度比较快；Swing是基于AWT 的Java程序，其运行速度比较慢。对于一个嵌入式应用来说，目标平台的硬件资源往往非常有限，而应用程序的运行速度又是项目中至关重要的因素。在这种矛盾的情况下，简单而高效的AWT 当然成了嵌入式Java的第一选择。而在普通的基于PC或者是工作站的标准Java应用中，硬件资源对应用程序所造成的限制往往不是项目中的关键因素，所以在标准版的Java中则提倡使用Swing， 也就是通过牺牲速度来实现应用程序的功能。<br>  通俗的话:<br>　　AWT 是抽象窗口组件工具包，是 java 最早的用于编写图形节目应用程序的开发包。Swing 是为了解决 AWT 存在的问题而新开发的包，它以 AWT 为基础的。</p>
<h2 id="18-Swing引入的包"><a href="#18-Swing引入的包" class="headerlink" title="18.Swing引入的包"></a>18.Swing引入的包</h2><pre><code>import javax.swing.*;//注意是 javax
</code></pre><h2 id="19-顶层容器JFrame、jDialog、japplet"><a href="#19-顶层容器JFrame、jDialog、japplet" class="headerlink" title="19.顶层容器JFrame、jDialog、japplet"></a>19.顶层容器JFrame、jDialog、japplet</h2><p>　　<strong>JFrame</strong>:用来设计类似于Windows系统中的窗口形式的应用程序。<br>　　<strong>JDialog</strong>:和JFrame类似，只不过JDialog是用来设计对话框。<br>　　<strong>JApplet</strong>:用来设计可以在嵌入在网页中的Java小程序。   </p>
<h2 id="20-窗体、容器的默认布局"><a href="#20-窗体、容器的默认布局" class="headerlink" title="20.窗体、容器的默认布局"></a>20.窗体、容器的默认布局</h2><p>   　　Frame是框架，这个是要实现的功能界面的布局，默认管理器“BorderLayout”；<br><img src="/picture/b1.jpg" alt=""><br>　　Panel是面板，这个是要实现的某个功能模块的具体实现，默认管理器“FlowLayout“；<br>　　1. <strong>BorderLayout:</strong>将版面划分成东、西、南、北、中五个区域，将添加的组件按指定位置放置。-java.awt.BorderLayout<br>　　2. <strong>FlowLayout:</strong>组件按从左到右而后从上到下的顺序依次排列，一行不能放完则折到下一行。-java.awt.FlowLayout<br>　　3. <strong>GridLayout:</strong>矩形网格形式对容器的组件进行布置-java.awt.GridLayout<br>　　4. <strong>GridBagLayout:</strong>GridBagLayout以表格形式布置容器内的组件，将每个组件放置在每个单元格内，而一个单元格可以跨越多个单元格合并成一个单元格，即多个单元格可以组合成一个单元格，从而实现组件的自由布局。-java.awt.GridBagLayout<br>　　5. <strong>CardLayout:</strong>以层叠的方式布置组件，如同很多张卡片叠在一起，从而只能看到最上面的那一张卡片。-java.awt.CardLayout<br>　　6. <strong>BoxLayout:</strong>以嵌套式盒子来管里容器的布局，通过将组件放入水平或垂直形盒子以多层嵌套的方式进行布局。-javax.swing.BoxLayout  </p>
<h2 id="21-Event事件，事件源，事件监听，事件处理"><a href="#21-Event事件，事件源，事件监听，事件处理" class="headerlink" title="21.Event事件，事件源，事件监听，事件处理"></a>21.Event事件，事件源，事件监听，事件处理</h2><p>　　1.event object：事件状态对象，用于listener的相应的方法之中，作为参数，一般存在与listerner的方法之中<br>　　2.event source：具体的事件源，比如说，你点击一个button，那么button就是event source，要想使button对某些事件进行响应，你就需要注册特定的listener。<br>　　3.event listener：对每个明确的事件的发生，都相应地定义一个明确的Java方法。这些方法都集中定义在事件监听者（EventListener）接口中，这个接口要继承 java.util.EventListener。 实现了事件监听者接口中一些或全部方法的类就是事件监听者。<br>　　伴随着事件的发生，相应的状态通常都封装在事件状态对象中，该对象必须继承自java.util.EventObject。事件状态对象作为单参传递给应响应该事件的监听者方法中。发出某种特定事件的事件源的标识是：遵从规定的设计格式为事件监听者定义注册方法，并接受对指定事件监听者接口实例的引用。<br>　　具体的对监听的事件类，当它监听到event object产生的时候，它就调用相应的方法，进行处理。</p>
<h2 id="22-加监听、常用事件监听"><a href="#22-加监听、常用事件监听" class="headerlink" title="22.加监听、常用事件监听"></a>22.加监听、常用事件监听</h2><pre><code>Button awtButton = new Button();            //import java.awt.Button;
    JButton swingButton  =new JButton(); 　　//import javax.swing.JButton;

    awtButton.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            // TODO Auto-generated method stub

        }
    });
</code></pre><h2 id="23-网络编程相关类"><a href="#23-网络编程相关类" class="headerlink" title="23.网络编程相关类"></a>23.网络编程相关类</h2><p>针对网络通信的不同层次，Java提供的网络功能有四大类：InetAddress 、URLs、Sockets、Datagram<br>1、InetAddress面向的是网络层（IP层），用于标识网络上的硬件资源。<br>2、 URL面向的应用层，通过URL，Java程序可以直接送出或读入网络上的数据。<br>3、 Sockets和Datagram面向的则是传输层。Sockets使用的是TCP协议，这是传统网络程序最常用的方式，可以想象为两个不同的程序通过网络的通信信道进行通信。Datagram则使用UDP协议，是另一种网络传输方式，它把数据的目的地纪录在数据包中，然后直接放在网络上。</p>
<h2 id="24-设计模式：策略模式"><a href="#24-设计模式：策略模式" class="headerlink" title="24.设计模式：策略模式"></a>24.设计模式：策略模式</h2><pre><code>//抽象折扣类

public interface MemberStrategy {
/**
 * 计算图书的价格
 * @param booksPrice    图书的原价
 * @return    计算出打折后的价格
 */
   public double calcPrice(double booksPrice);
}

//初级会员折扣类

public class PrimaryMemberStrategy implements MemberStrategy {

@Override
public double calcPrice(double booksPrice) {

    System.out.println(&quot;对于初级会员的没有折扣&quot;);
    return booksPrice;
  }
}

//中级会员折扣类

public class IntermediateMemberStrategy implements MemberStrategy {

@Override
public double calcPrice(double booksPrice) {

    System.out.println(&quot;对于中级会员的折扣为10%&quot;);
    return booksPrice * 0.9;
 }
}  
//高级会员折扣类  

public class AdvancedMemberStrategy implements MemberStrategy {
@Override
public double calcPrice(double booksPrice) {

    System.out.println(&quot;对于高级会员的折扣为20%&quot;);
    return booksPrice * 0.8;
  }
 }  
//价格类(相当于上下文)  
public class Price {
   //持有一个具体的策略对象
    private MemberStrategy strategy;
/**
 * 构造函数，传入一个具体的策略对象
 * @param strategy    具体的策略对象
 */
public Price(MemberStrategy strategy){
    this.strategy = strategy;
}

/**
 * 计算图书的价格
 * @param booksPrice    图书的原价
 * @return    计算出打折后的价格
 */
public double quote(double booksPrice){
    return this.strategy.calcPrice(booksPrice);
  }
}  
//客户端:  

public class Client {
public static void main(String[] args) {
    //选择并创建需要使用的策略对象
    MemberStrategy strategy = new AdvancedMemberStrategy();
    //创建环境
    Price price = new Price(strategy);
    //计算价格
    double quote = price.quote(300);
    System.out.println(&quot;图书的最终价格为：&quot; + quote);
  }
 }
</code></pre><h2 id="25-中介者模式"><a href="#25-中介者模式" class="headerlink" title="25.中介者模式"></a>25.中介者模式</h2><p><img src="/picture/MediatorPattern.jpg" alt="">  </p>
<pre><code>abstract class AbstractColleague {
protected int number;

public int getNumber() {
    return number;
}

public void setNumber(int number){
    this.number = number;
}
//注意这里的参数不再是同事类，而是一个中介者
public abstract void setNumber(int number, AbstractMediator am);
}

class ColleagueA extends AbstractColleague{

public void setNumber(int number, AbstractMediator am) {
    this.number = number;
    am.AaffectB();
 }
}

class ColleagueB extends AbstractColleague{

@Override
public void setNumber(int number, AbstractMediator am) {
    this.number = number;
    am.BaffectA();
 }
}

abstract class AbstractMediator {
protected AbstractColleague A;
protected AbstractColleague B;

public AbstractMediator(AbstractColleague a, AbstractColleague b) {
    A = a;
    B = b;
}

public abstract void AaffectB();

public abstract void BaffectA();

}
class Mediator extends AbstractMediator {

public Mediator(AbstractColleague a, AbstractColleague b) {
    super(a, b);
}

//处理A对B的影响
public void AaffectB() {
    int number = A.getNumber();
    B.setNumber(number*100);
}

//处理B对A的影响
public void BaffectA() {
    int number = B.getNumber();
    A.setNumber(number/100);
 }
}

public class Client {
public static void main(String[] args){
    AbstractColleague collA = new ColleagueA();
    AbstractColleague collB = new ColleagueB();

    AbstractMediator am = new Mediator(collA, collB);

    System.out.println(&quot;==========通过设置A影响B==========&quot;);
    collA.setNumber(1000, am);
    System.out.println(&quot;collA的number值为：&quot;+collA.getNumber());
    System.out.println(&quot;collB的number值为A的10倍：&quot;+collB.getNumber());

    System.out.println(&quot;==========通过设置B影响A==========&quot;);
    collB.setNumber(1000, am);
    System.out.println(&quot;collB的number值为：&quot;+collB.getNumber());
    System.out.println(&quot;collA的number值为B的0.1倍：&quot;+collA.getNumber());

 }
}
</code></pre><h2 id="26-异常处理"><a href="#26-异常处理" class="headerlink" title="26.异常处理"></a>26.异常处理</h2><p>　　　对于可能出现异常的代码，有两种处理办法：<br>    第一、在方法中用try…catch语句捕获并处理异常，catach语句可以有多个，用来匹配多个异常。例如：  </p>
<pre><code>public void p(int x){
 try{
  ...
 }catch(Exception e){
  ...
 }finally{
  ...
 }
}
</code></pre><p>第二，对于处理不了的异常或者转型异常，用throws抛出</p>
<pre><code>public void test1() throws MyException{//抛出产生的异常
 ...
 if(....){
  throw new MyException();//用于产生异常
  }
} 
</code></pre><h2 id="27-数组的使用"><a href="#27-数组的使用" class="headerlink" title="27.数组的使用"></a>27.数组的使用</h2><ol>
<li>声明一个数组 </li>
</ol>
<p>Java代码 </p>
<pre><code>String[] aArray = new String[5];  
String[] bArray = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;, &quot;d&quot;, &quot;e&quot;};  
String[] cArray = new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;};  
</code></pre><ol>
<li>输出一个数组 </li>
</ol>
<p>Java代码 </p>
<pre><code>int[] intArray = { 1, 2, 3, 4, 5 };  
String intArrayString = Arrays.toString(intArray);  

// print directly will print reference value  
System.out.println(intArray);  
// [I@7150bd4d  

System.out.println(intArrayString);  
// [1, 2, 3, 4, 5]  
</code></pre><ol>
<li>从一个数组创建数组列表 </li>
</ol>
<p>Java代码 </p>
<pre><code>String[] stringArray = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };  
ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(stringArray));  
System.out.println(arrayList);  
// [a, b, c, d, e]  
</code></pre><ol>
<li>检查一个数组是否包含某个值 </li>
</ol>
<p>Java代码 </p>
<pre><code>String[] stringArray = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };  
boolean b = Arrays.asList(stringArray).contains(&quot;a&quot;);  
System.out.println(b);  
// true  
</code></pre><ol>
<li>连接两个数组 </li>
</ol>
<p>Java代码 </p>
<pre><code>int[] intArray = { 1, 2, 3, 4, 5 };  
int[] intArray2 = { 6, 7, 8, 9, 10 };  
// Apache Commons Lang library  
int[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);  
</code></pre><ol>
<li>声明一个内联数组（Array inline） </li>
</ol>
<p>Java代码 </p>
<pre><code>method(new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;});  
</code></pre><ol>
<li>把提供的数组元素放入一个字符串 </li>
</ol>
<p>Java代码 </p>
<pre><code>// containing the provided list of elements  
// Apache common lang  
String j = StringUtils.join(new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, &quot;, &quot;);  
System.out.println(j);  
// a, b, c  
</code></pre><ol>
<li>将一个数组列表转换为数组 </li>
</ol>
<p>Java代码 </p>
<pre><code>String[] stringArray = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };  
ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(stringArray));  
String[] stringArr = new String[arrayList.size()];  
arrayList.toArray(stringArr);  
for (String s : stringArr)  
System.out.println(s);  
</code></pre><ol>
<li>将一个数组转换为集（set） </li>
</ol>
<p>Java代码 </p>
<pre><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(stringArray));  
System.out.println(set);  
//[d, e, b, c, a]  
</code></pre><ol>
<li>逆向一个数组 </li>
</ol>
<p>Java代码 </p>
<pre><code>int[] intArray = { 1, 2, 3, 4, 5 };  
ArrayUtils.reverse(intArray);  
System.out.println(Arrays.toString(intArray));  
//[5, 4, 3, 2, 1]  
</code></pre><ol>
<li>移除数组中的元素 </li>
</ol>
<p>Java代码 </p>
<pre><code>int[] intArray = { 1, 2, 3, 4, 5 };  
int[] removed = ArrayUtils.removeElement(intArray, 3);//create a new array  
System.out.println(Arrays.toString(removed));  
</code></pre><ol>
<li>将整数转换为字节数组 </li>
</ol>
<p>Java代码 </p>
<pre><code>byte[] bytes = ByteBuffer.allocate(4).putInt(8).array();  

for (byte t : bytes) {  
   System.out.format(&quot;0x%x &quot;, t);  
}  
</code></pre><h2 id="28-equals与"><a href="#28-equals与" class="headerlink" title="28.equals与=="></a>28.equals与==</h2><p>java中的数据类型，可分为两类：<br>1.基本数据类型，也称原始数据类型。<br>　　byte,short,char,int,long,float,double,boolean<br>　　他们之间的比较，应用双等号（==）,比较的是他们的值。<br>2.复合数据类型(类)<br>　　当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。<br>　　<strong> JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 </strong><br>　　对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。</p>
<h2 id="29-线程"><a href="#29-线程" class="headerlink" title="29.线程"></a>29.线程</h2><p>　　Java多线程实现方式主要有三种：继承Thread类、实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程。其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。<br>1、继承Thread类实现多线程<br>继承Thread类的方法尽管被我列为一种多线程实现方式，但Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。例如： </p>
<pre><code>public class MyThread extends Thread {
　　 public void run() {
　　 System.out.println(&quot;MyThread.run()&quot;);
　　  }
   }
</code></pre><p>2、实现Runnable接口方式实现多线程<br>如果自己的类已经extends另一个类，就无法直接extends Thread，此时，必须实现一个Runnable接口，如下：</p>
<pre><code>public class MyThread extends OtherClass implements Runnable {
　　public void run() {
　　 System.out.println(&quot;MyThread.run()&quot;);
　　}
}
</code></pre><p>为了启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例：  </p>
<pre><code>MyThread myThread = new MyThread();
Thread thread = new Thread(myThread);
thread.start();  
</code></pre><p>事实上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，参考JDK源代码  </p>
<pre><code>public void run() {
　　if (target != null) {
　　 target.run();
　　}
}
</code></pre><h2 id="30-内部类"><a href="#30-内部类" class="headerlink" title="30.内部类"></a>30.内部类</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Oracle数据库-五-SQL基本查询]]></title>
      <url>hubaoquan.github.io/2016/12/12/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%94-SQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<h1 id="5-1-SELECT-基本查询语句"><a href="#5-1-SELECT-基本查询语句" class="headerlink" title="5.1 SELECT 基本查询语句"></a>5.1 SELECT 基本查询语句</h1><p>  　　<strong>1.使用计算列</strong><br>　　　　　１．查询scott方案下的emp表中每个雇员的姓名和将工资增sal加300后的新工资。<br>　　　　　<code>SELECT ename ||&#39;的工作是&#39;||job AS 雇员,sal + 300 AS 新工资 FROM scott.emp;</code><br><a id="more"></a></p>
<h2 id=""><a href="#" class="headerlink" title="  "></a><img src="\picture\orcale5-1.png" alt="">  </h2><p>　　　<strong>2.DISTINCT关键字</strong><br>　　　　　使用DISTINCT可以从结果中消除重复行。<br>　　　　　例如：查询emp表中的job和deptno字段，要求去除重复行.<br>        　　　　　　 <code>SELECT DISTINCT job,deptno FROM emp;</code>  </p>
<hr>
<p>　　  <strong>3.WHERE子句</strong><br>　　　　where子句的功能是查找符合条件的记录：<br>　　　　1.比较运算符  （＝、&gt;、&lt;、&lt;=、&gt;=、&lt;&gt;或！、！&gt;、！&lt;）<br>　　　　2.逻辑运算符  (OR  AND  NOT)<br>　　　　3.字符串模式匹配<br>　　　　　　%表示字符串包括0个或多个任意字符<br>　　　　　　＿表示包含一个任意字符<br>　　　　　　倒数第二个字母是Ｅ的员工：<code>SELECT * FROM emp WHERE　ename LIKE &#39;%E_&#39;；</code><br>　　　　4.范围比较<br>　　　　　<code>BETWEEN  AND</code><br>　　　　5.使用查询列表<br>　　　　　　<code>IN</code>:  where column_name in (value1,value2,value3);<br>　　　　6.空值判定<br>　　　　　　IS NULL：空<br>　　　　　　NOT NULL：非空  </p>
<hr>
<p>　　　<strong>4.ORDER BY子句</strong><br>　　　　　 对查询结果进行排序：<br>　　　　　　　ASC：升序排序<br>　　　　　　　DESC：降序排序<br>　　　　　　  默认为升序ASC排序，可以用字段序号或字段别名排序：<br>　　　　　　　　<code>SELECT ename,sal FROM emp ORDER BY sal DESC;</code><br>　　　　　　　可以指定多列数据排序，先将第一列数据排序，再按第二列排序。</p>
<hr>
<p>　　　<strong>5.使用统计函数</strong><br>　　　　　　　AVG、MAX、MIN、SUM、COUNT、COUNT(*)  </p>
<hr>
<p>　　　<strong>6.GROUP BY子句</strong><br>　　　　　　统计emp表中每个工作的员工人数：<br>　　　　　　　<code>SELECT job,COUNT(*) AS 人数 FROM emp GROUP BY job;</code><br>　　　　　　统计emp中每个部门中各种工作相同的员工人数:<br>　　　　　　　<code>SELECT dept,job,COUNT(*) AS 人数 FROM emp GROUP BY deptno,job;</code> </p>
<hr>
<p>　　　<strong>7.HAVING子句</strong><br>　　　　　使用GROUP BY子句和统计函数后还可以使用HAVING子句进行再次的筛选。WHERE是对表中已有数据进行筛选。<br>　　　　　1.统计平均工资大于2500的工作<br>　　　　　　　<code>SELECT job,AVG(sal) AS 平均工资 FROM emp GROUP BY job HAVING AVG(sal)&gt;2500;</code><br>　　　　　  在SELECT语句中，先WHERE语句、再GROUP BY、后HAVING语句。<br>　　　　　2.统计emp中1982年后参加工作的、雇员人数超过2人的部门编号<br>　　　　　　<code>SELECT deptno,COUNT(8) AS 人数</code><br>　　　　　　<code>FROM emp</code><br>　　　　　　<code>WHERE hiredate&gt;&#39;1 -1月 -1982&#39;</code><br>　　　　　　<code>GROUP BY deptno</code><br>　　　　　　<code>HAVING COUNT(*)&gt;=2</code></p>
<hr>
<h1 id="5-2-SQL-PLUS-中常用函数介绍"><a href="#5-2-SQL-PLUS-中常用函数介绍" class="headerlink" title="5.2 SQL*PLUS 中常用函数介绍"></a>5.2 SQL*PLUS 中常用函数介绍</h1><p><strong>1.字符串函数</strong>  </p>
<ul>
<li>CONCAT:连接两个字符串</li>
<li>LENGTH：返回字符串长度</li>
<li>LOWER：转小写</li>
<li>UPPER：转大写</li>
<li>INITCAP：首字母转大写</li>
<li>INSTR(string,value)：查询字符value在string中的位置</li>
<li>LPAD(string,length[,padding])：在字符串左侧填充padding字符length长度，没指定padding用空格填充</li>
<li>RPAD(string,length[,padding])：同上在右侧填充</li>
<li>REPLACE(string,old,new)：用new字符串替换old字符串，如果没有指定new或new为空，则删除old字符串</li>
<li>SUBSTR(string,start,length)：获取子串，从start开始长度为length。<br><em>在使用这些函数时需要一个特殊的表－－DUAL。</em>  </li>
</ul>
<hr>
<p><strong>2.数值函数</strong>  </p>
<ul>
<li>ABS：绝对值</li>
<li>CEIL：大于或等于value的最小值</li>
<li>FLOOR：等于或小于value的最大值</li>
<li>COS：求余弦值</li>
<li>COSH：求反余弦值</li>
<li>EXP：返回以e为底的指数</li>
<li>LN：返回自然对数值</li>
<li>POWER(vakue,exponent)：返回value^exponent</li>
<li>SQRT：返回value的平方根</li>
<li>ROUND(value，precision)：将value按precision进行四舍五入</li>
<li>MOD(value,divisor)：求余</li>
<li>TRUNC(value,precision):将value按精度precision进行截取</li>
</ul>
<hr>
<p><strong>3.日期时间函数</strong>  </p>
<ul>
<li>ADD_MONTHS(date,number):在指定日期date上增加number个月</li>
<li>LAST_DAY(date):返回date所在月的最后一天</li>
<li>MONTHS_BETWEEN(date1，date2)：返回date1与date2之间间隔多少天</li>
<li>NEW_TIME(date,old_zone,new_zone):将日期date从时区old_zone转换到new_zone</li>
<li>NEXT_DAY(date,’day’):返回date后的下个星期day的日期</li>
<li>SYSDATE：返回系统当前日期</li>
<li>CURRENT_TIMESTAMP：返回当前的日期和时间</li>
<li>EXTRACT(c1 from d1):从日期c1中抽取指定的年、月、日、时、分、秒  </li>
</ul>
<hr>
<p><strong>4.转换函数</strong>  </p>
<ul>
<li>TO_CHAR(date,’format’):按照format格式将date转换为字符串</li>
<li>TO_NUMBER(char):将包含数字的字符串转换为数值类型</li>
<li>TO_DATE(string,’format’):将日期格式的字符串转换为日期型</li>
<li>CHARTOROWID(char): 将字符串转换为ROWID格式</li>
<li>ROWIDTOCHAR(x):将ROWID转换为字符串</li>
</ul>
<hr>
<h1 id="5-3-SQL-PLUS格式化查询结果"><a href="#5-3-SQL-PLUS格式化查询结果" class="headerlink" title="5.3 SQL*PLUS格式化查询结果"></a>5.3 SQL*PLUS格式化查询结果</h1><ol>
<li>linesize:设置在一行中所能显示的总字符数</li>
<li>space：设置每列之间的空格数</li>
<li>timing：设置是否统计每个SQL命令的执行时间  </li>
</ol>
<h1 id="5-4-SQL脚本文件的创建与执行"><a href="#5-4-SQL脚本文件的创建与执行" class="headerlink" title="5.4 SQL脚本文件的创建与执行"></a>5.4 SQL脚本文件的创建与执行</h1><p>　　　将ｓｑｌ语句保存为脚本文件：<code>SELECT * FROM emp; SAVE D:\select_emp.sql</code><br>　　　执行脚本文件：＠D:\select_emp.sql 或 @@D:\select_emp.sql或 START D:\select_emp.sql<br>　　　@：必须给出脚本完整路径<br>　　　@@: 如果执行在当前路径可以不用完整路径</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Oracle数据库复习]]></title>
      <url>hubaoquan.github.io/2016/12/11/Oracle/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p><strong>物理存储结构</strong> ：每一个数据库主要包括四种类型文件：数据文件（dbf）、日志文件（log）、控制文件(ctl)、初始化参数文件（spfile.ora）</p>
<p><strong>逻辑存储结构</strong> ：表空间、段、盘区、数据块</p>
<p><strong>表空间是数据库中最大的的逻辑存储结构</strong> 。逻辑结构上的表空间与物理结构上的数据文件是有关联的：数据库中的表空间至少包含一个或多个数据文件，而一个数据文件只能属于一个表空间。这种关联实现了数据块的逻辑结构和物理结构的统一。<br><a id="more"></a><br>段：一个表空间被分成多个段，一个段有可以被分成若干个盘区。</p>
<p>盘区：逻辑存储结构中的一个重要概念，是Oracle最小的磁盘分配单元。</p>
<p>数据块：是Oracle最小的逻辑存储单元，是最基本的数据存取单位。</p>
<p>2.3.1进程结构</p>
<pre><code>1.用户进程

2.服务进程
</code></pre><p>   　　　用户进程和服务进程之间的对应关系是由Oracle的工作模式决定的，数据库通常有两种工作模式：专用服务器模式和共享服务器模式。</p>
<p>   　　（1）专用服务器模式：用户创建Oracle数据块是的，默认方式，也是多数数据库管理员运行数据库的方式，他为用户进程和服务进程提供了一对一的映射关系</p>
<p>　　（2）共享服务器模式：数据库启动时创建几个共享的服务进程，这些进程可以为多个用户提供服务，他们之间是一对多的关系。</p>
<p>   3.后台进程</p>
<p>2.3.2 内存结构</p>
<p>　　　1.系统全局区（ＳＧＡ）</p>
<p>　　　ＳＧＡ是所有Ｏｒａｃｌｅ进程都能访问的一组内存区域的集合，包含了Ｏｒａｃｌｅ服务进程的数据和控制信息。</p>
<p>　　　　　数据缓存区、重做日志缓冲区、共享池、java池、大型池</p>
<pre><code>2.程序全局区

 PGA是提供各付存储自己的数据及控制信息的内存区域，与SGA相比，PGA是私有的。
</code></pre><p>2.4 网络配置文件</p>
<ol>
<li><p>sqlnet.ora</p>
<p>  指定数据库链接账号的验证方式以及链接字符串的解析方式。</p>
</li>
<li><p>tnsnames.ora</p>
<p>   客户端链接远程主机服务器的主机字符串。</p>
</li>
<li><p>listener.ora</p>
<p>  作用于Oracle数据库服务端是Oracle监听服务的配置文件。</p>
</li>
</ol>
<p>第三章</p>
<p>3.1.1 用户与方案的概念</p>
<ol>
<li><p>用户:Oracle通俗的讲就是访问数据库的人。每个用户都有口令和相应权限，使用正确的用户名和口令才能进入数据库进行数据的存取操作。</p>
<p>2.方案：方案是一切逻辑数据结构或对象的集合。一个方案能被一个数据库用户拥有，并且方案的名称和这个用户的名称相同，当用户创建时，这个用户的方案也会被创建。Oracle中的方案是对数据库的局部逻辑描述。</p>
<p>同一个方案中不能存在相同的表，但是可以在不同方案中有相同名字的表，只需要在使用时用方案名.表名就可以了。</p>
</li>
</ol>
<p>3.1.2 方案对象与非方案对象</p>
<pre><code>**方案对象** ：是指属于某个方案中的数据库对象。Oracle中方案对象有：表、索引、索引表、簇、触发器、PL/SQl包、序列、同义词、视图、存储函数与存储过程、JAVA类与其他java资源。

**非方案对象** ：有些数据库数据对象不属于任何方案，而属于整个数据库，这些对象被称为非方案对象。非方案对象有：表空间、用户、角色、回退段、概要文件。
</code></pre><p>3.2.2 用户创建</p>
<p>   创建有个名为hbq密码为123456的用户</p>
<p><strong>    CREATE USER hbq IDENTIFIED BY 123456;</strong></p>
<p><strong>   </strong> 创建名为hbq密码为123456表空间名为users表空间大小为10m的用户。</p>
<p><strong>CREATE USER hbq IDENTIFIED BY 123456</strong></p>
<p><strong>DEFAULT TABLESPACE users</strong></p>
<p><strong>QUOTA 10M ON users ；</strong></p>
<p><strong> </strong>  创建名为 hbq 密码为123456 密码为过期并且状态为锁的用户：<br> <strong>   CREATE USER hbq IDENTIFIED BY 123456</strong></p>
<p><strong>PASSWORD expire</strong></p>
<p><strong>ACCOUNT lock；</strong></p>
<p><strong> </strong>  给hbq授予数据库系统会话权(系统管理员)： <strong>GRANT CREATE SESSION TO hbq；</strong></p>
<p>   给hbq授予数据库链接角色： <strong>GRANT CONNECT TO hbq;</strong></p>
<p>   用hbq链接数据库： <strong>CONNECT hbq/123456;</strong></p>
<p>3.3.2 修改用户</p>
<pre><code>１．修改ｈｂｑ的密码为123，并开启无限大用户空间
</code></pre><p>　　　 <strong>ALTER USER hbq</strong></p>
<p><strong>      IDENTIFIED BY 123</strong></p>
<p><strong>      DEFAULT TABLESPACE users</strong></p>
<p><strong>      QUOTA UNLIMITED ON users;</strong></p>
<pre><code>2.禁用用户hbq： **ALTER USER hbq ACCOUNT LOCK；**
</code></pre><p><strong>       </strong> 启用用户hbq： <strong>ALTER USER　hbq ACCOUNT UNLOCK;</strong></p>
<p><strong>     </strong>  连接hbq; CONNECT hbq/123;</p>
<pre><code>3.删除用户hbq： DROP USER hbq;
</code></pre><ol>
<li>第四章表的创建与管理</li>
</ol>
<p><strong>  4.1 创建表</strong></p>
<p><strong>4.1.1 基本数据类型:</strong> 字符（char）、数值（NUMBER）、日期（DATE）、LOB(非结构化数据)、ROWID (表中每条记录的物理地址)</p>
<ol>
<li>char：char、nchar、long、varchar2、nvarchar2（加n的为可以存储Unicode字符）</li>
<li>Number：INTEGER、 INT、SMALLINT、FLOAT、REAL（NUMBER（p，s）p为精度，s为小数位数，如果不指定则为38位浮点数）</li>
<li>DATE：可以用函数SYSDATE获得当前系统的时间。</li>
</ol>
<p>4.ＬＯＢ数据类型：BLOB（二进制大对象，可以存储视频、图像等）</p>
<pre><code>CLOB（字符大对象）

BFILE(外部二进制文件)
</code></pre><p>4.1.3使用SQL创建表</p>
<pre><code>在当前方案中创建一个名为student的表，包含学号（studentID）、姓名（name）、性别（sex）默认为&amp;#39;男&amp;#39;、出生日期（birthday）
</code></pre><p>   CREATE  TABLE student(</p>
<pre><code>studentID   CHAR(6),

Name      VARCHAR(8),

Sex        CHAR(2) DEFAULT &amp;#39;男&amp;#39;,

Birthday    DATE)
</code></pre><p>   TABLESPACE users;</p>
<p>4.1.4 基于已有的表创建新表</p>
<pre><code>将scott方案中的emp表复制到当前方案my\_emp表中
</code></pre><p>   CREATE  TABLE  my_emp</p>
<p>   AS  SELECT  *  FROM  scott.emp;</p>
<pre><code>将部分列复制到新表中：
</code></pre><p>   CREATE TABLE my_emp( e_number,e_name,e_job)</p>
<p>   AS SELECT empno,ename,job FROM scott.emp;</p>
<p>4.1.6使用 DESC 命令查看表结构：   <strong>DESC 表名；</strong></p>
<p><strong>4.2 向表中插入、修改删除数据</strong></p>
<p>4.2.1插入数据</p>
<pre><code> 1.插入单行数据

向student表中插入完整记录

INSERT INTO student

VALUES(&amp;#39;20140816&amp;#39;,&amp;#39;姓名&amp;#39;,&amp;#39;男&amp;#39;,&amp;#39;2016-12-11&amp;#39;)；

可以只插入部分数据：

INSERT INTO student

VALUES(&amp;#39;20140816&amp;#39;,&amp;#39;姓名&amp;#39;,DEFAULT,NULL)；

2.插入多行数据

从已有表中选择多行数据插入到表中

INSERT  INTO  表名

SELECT  \*  FROM  已有的表；

注：只有表结构相同才能这样插入，也可以插入部分数据。
</code></pre><p>4.2.2 修改数据（UPDATE）</p>
<pre><code>1. 将emp表中的7296号员工的工作改为SALESMAN（假如员工都存在）

     UPDATE  scott.emp

     SET job = &amp;#39;SALESMAN&amp;#39;

     WHERE eno = 7296;

2.将emp表中1235号员工工作改为1236号员工工作相同（假如员工都存在）

     UPDATE scott.emp

     SET job = (SELECT job FROM emp  WHERE eno =1236)

     WHERE eno = 1235；

3.将SALSMAN的工资都增长5%

     UPDATE scott.emp

     SET sal = sal +(sal\*0.05)
</code></pre><p>WHERE job = &#39;SALSMAN&#39;</p>
<p>4.2.3 删除数据</p>
<pre><code>   DELETE逻辑删除，可以回滚

   TRUNCATE 删除表，物理删除无法恢复

1.DELETE命令：删除工作为SALESMAN的雇员

  DELETE FROM scott.emp

  WHERE　job = &amp;#39;SALSMAN&amp;#39;

  删除后还可以使用命令回滚：ROLLBACK；

2. TRUNCATE   TABLE  表名；

   永久删除不能恢复
</code></pre><p>   4.3 修改与删除表</p>
<pre><code>4.3.1 修改表

     1. 向student表添加一列系sdept ,宿舍号flat

        ALTER TABLE student

        ADD ( sdept VARCHAR(20),flat CHAR(4) )

     2. 删除student表中的sdept列（仅删除一列）

        ALTER TABLE student

        DROP COLUMN sdept；

     3. 删除student中的sex 和flat列（删除多列）

        ALTER TABLE student

        DROP (sex,flat)

       注：删除一列和删除多列的语法不同

     4. 修改student表中的sdept字段长度为char (10)

        ALTER TABLE student

        MODIFY sdept CAHR(10)；

        注：如果扩大长度没有任何限制，如果缩小长度，可变长度类型可以不可变长度比如 char 和 number 不可以缩小

     5. 修改sdept字段名为new\_sdept

       ALTER TABLE student

       RENAME COLUMN sdept TO new\_sdept;

     6. 将student表重名为new\_studnet

       ALTER TABLE student

       RENAME  TO new\_student;

     7. 删除表 ：   DROP  表名；
</code></pre><p>4.4 定义数据完整性</p>
<p>数据完整性是指数据的正确性、一致性和安全性，他是衡量数据库中数据质量的好坏的重要标准。</p>
<p>为什么要定义数据完整性：在执行insert、delete、update时数据库的完整性可能会遭到破坏。比如：将无效的数据插入数据库或者将存在的数据修改为无效的数据，对数据库的修改不一致等。</p>
<p>约束是保证数据完整性的标准方法，主要包括：主键（PRIMARY KEY）约束、非空约束、唯一性约束、非空约束、检查约束、外键约束、</p>
<ol>
<li>列级约束：如果约束作用在一列上那么就是列级约束。可以在创建时直接在后面写上列级约束。</li>
<li><p>表级约束：如果约束作用于多个字段那么就是表级约束。表级约束必须在定义完列字段后才能定义。</p>
<p>约束可以在建表时定义也可以在建表后修改。</p>
</li>
</ol>
<p>4.4.1 定义主键约束</p>
<ol>
<li>创建表时定义主键约束</li>
</ol>
<p>CREATE TABLE student (</p>
<pre><code>**Stu\_ID CHAR(6) PRIMARY KEY，**①在定义字段后直接指定.自动生成约束名

**Stu\_ID CHAR(6) CONSTRAINT pk\_student PRIMARY KEY，**②指定主键名和主键
</code></pre><p>　Stu_nane   CHAR(10),</p>
<p>   Stu_sex    CHAR(2)</p>
<p>)</p>
<p>③另起一行注明主键</p>
<p> CREATE TABLE student (</p>
<p>  Stu_ID CHAR(6) ，</p>
<p>  <strong>CONSTRAINT pk_student</strong>  <strong>PRIMARY KEY（Stu_ID ）**</strong> ，**</p>
<p>　Stu_nane   CHAR(10),</p>
<p>   Stu_sex    CHAR(2)，</p>
<p><strong>PRIMARY KEY（Stu_ID ）④最后边定义主键</strong></p>
<p>)</p>
<ol>
<li><p>用多个字段组成主键</p>
<p>   CONSTRAINT pk_student  PRIMARY  KEY（stu_id,stu_name）;</p>
</li>
<li><p>为已经创建的表定义主键</p>
<p>ALTER TABLE student</p>
<p>ADD CONSTRAINT pk_student PRIMARY(stu_id);</p>
</li>
<li><p>删除主键约束</p>
<pre><code>ALTER TABLE student

DROP CONSTRAINT pk\_student;
</code></pre></li>
</ol>
<p>4.4.3 定义唯一性约束 UNIQUE</p>
<pre><code> 一张表只能定义一个主键但是可以定义多个唯一性约束

UNIQUE约束允许在该列上有NULL而主键约束不可以。

①创建唯一性约束，只需在创建表时，在字段后加关键字UNIQUE。

②修改唯一性约束

 ALTER TABLE

 ADD CONSTRAINT un\_identity UNIQUE（字段名）;
</code></pre><p>4.4.4 定义检查约束 CHECK</p>
<pre><code>①比如：年龄在20-30之间的约束

age  NUMBER  CONSTRAINT  ck\_age  CHECK (age&amp;lt;30 and age&amp;gt;20);

②限制输入正确的系

dept  CHAR(10)   CONSTRAINT c k\_dept  CHECK  ( dept  IN (&amp;#39;软工&amp;#39;，&amp;#39;网工&amp;#39;))；
</code></pre><p>4.4.5 外键约束</p>
<pre><code>  定义外键约束

Dept_ID  INT  REFERENCES  department(Dept_ID);在后边定义

CONSTRAINT fk\_dept FOREIGN KEY(Dept_ID)

REFERENCES  department(Dept_ID)；

  修改外键约束

   ALTER TABLE emplee

   ADD CONSTRAINT fk_dept FOREIGN KEY(Dept_ID)

   REFERENCES deptment(Dept_ID)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的随笔]]></title>
      <url>hubaoquan.github.io/2016/12/11/Notes/%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<p>1.markdown文件名不是生成的post名，内容中的title名才是生成的post名。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序设计大赛成绩表]]></title>
      <url>hubaoquan.github.io/2016/11/29/Others/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E6%88%90%E7%BB%A9%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://pan.baidu.com/s/1c2mRt8c" target="_blank" rel="external">http://pan.baidu.com/s/1c2mRt8c</a> 密码：c8oa</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机组成原理第三章 习题23-28]]></title>
      <url>hubaoquan.github.io/2016/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%B9%A0%E9%A2%9823-28/</url>
      <content type="html"><![CDATA[<h2 id="答案仅供参考"><a href="#答案仅供参考" class="headerlink" title="答案仅供参考"></a>答案仅供参考</h2><p>23.某页式存储管理，页大小为2KB，逻辑地址空间包含16页，物理空间共有8页，逻辑地址应用多少位？主存物理空间有多大？<br><strong>解：逻辑地址空间包含16页，页大小为2KB，所以逻辑地址空间为32KB，逻辑地址应用4+11=15位<br>物理空间共有8页，页大小为2KB，所以主存物理空间16KB</strong><br><a id="more"></a><br>24.在一个分页虚存系统中，用户虚地址空间为32页，页长1KB，主存物理为16KB。已知用户程序有10页长，若虚页0、1、2、3已经被调入到主存8、7、4、10页中请问虚地址0AC5和1AC5(十六进制)对应的物理地址是多少？<br><strong>解：页长1KB，所以页内地址为10位。<br>主存物理页面数：16页，共14位地址码(其中页面号4位，页内地址10位)<br>用户虚地址空间：32页，页面号为031；共15位地址码(其中页面号5位，页内地址10位)<br>0AC5H=00010，1011000101B，页面号为2，已被调入到主存页4，所以，物理地址中的页面号为4，页内地址与虚地址的页内地址相同，所以是：0100，1011000101=12C5H<br>1AC5H=00110，1011000101B，页面号为6，未被调入到主存页中，所以无物理地址，会发生缺页中断。</strong></p>
<p>25.段式虚拟存储器对程序员是否透明？请说明原因。<br><strong>解：虚拟管理是由软件(操作系统)和硬件共同完成，由于软件的介入，虚存对实现存储管理系统程序不透<br>明。而段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。由于分段是由程序员完成的，所以段式虚拟存储器对程序员而言不是透明的，但虚存到实存的地址映射是由系统软件辅助完成的，故对应用程序而言，段式虚拟存储器是“半透明”的。</strong></p>
<p>26.在一个进程的执行过程中，是否其所有页面都必须处在主存中？<br><strong>解：在有虚拟存储管理系统中，程序不是一次整体装入内存才运行，所以不是所有页面都必须处在主存中，而是根据程序的局部性，有的页面在主存，有的页面在辅存。</strong></p>
<p>27.为什么在页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址，而在段式虚拟存储器地址变换时必须用段起址与段内偏移量相加才能得到物理地址？<br><strong>解：由于物理页与虚拟页的页面大小相同，且为2的整数次幂，所以页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址。而段式虚拟存储器的各段大小不同，且段起始地址任意，所以必须用段起址与段内偏移量相加才能得到物理地址。</strong></p>
<p>28.在虚存实现过程中，有些页面会在内存与外存之间被频繁地换入换出，使系统效率急剧下降。这种现象称为颠簸。请解释产生颠簸的原因，并说明防止颠簸的办法。<br><strong>解：<br>产生颠簸的原因主要有二：一是分配的页面数太少，二是替换策略不佳。<br>防止颠簸的办法：适当增加分配给用户程序的页面数，选取LRU或更好的替换策略。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NumPy数组]]></title>
      <url>hubaoquan.github.io/2016/11/01/Python/NumPy%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="一维数组的切片与索引"><a href="#一维数组的切片与索引" class="headerlink" title="一维数组的切片与索引"></a>一维数组的切片与索引</h2><p>1.一维Numpy数组和python列表切片一样</p>
<pre><code>&gt;&gt;&gt; numpy.arange(9)
array([0, 1, 2, 3, 4, 5, 6, 7, 8])
</code></pre><p>可以用下标选择元素，下标范围从0到7，并且每次递增2</p>
<pre><code>array[0:7:2]
array[0,2,4,6]
</code></pre><a id="more"></a>
<p>也可以用负数下标来反转数组:</p>
<pre><code>array[::-1]
</code></pre><hr>
<h2 id="数组的转换"><a href="#数组的转换" class="headerlink" title="数组的转换"></a>数组的转换</h2><p>1.构造多维数组</p>
<pre><code>&gt;&gt;&gt; b = numpy.arange(24).reshape(2,3,4)#
&gt;&gt;&gt; b
array([[[ 0,  1,  2,  3],
    [ 4,  5,  6,  7],
    [ 8,  9, 10, 11]],

   [[12, 13, 14, 15],
    [16, 17, 18, 19],
    [20, 21, 22, 23]]])
</code></pre><p>2.多维数组转一维数组拆解函数 brvel():</p>
<pre><code>&gt;&gt;&gt; b.ravel()
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,17, 18, 19, 20, 21, 22, 23])
</code></pre><p>3.多维数组转一维数组拉直函数 flatten():</p>
<p>flatten函数与brvel的功能是一样的只不过flatten返回的是一个真实的数组。而brvel返回的是数组的视图。</p>
<p>4.用元组指定数组形状</p>
<pre><code>b.shape = (6,4)     #指定数组的形状为6行4列
</code></pre><p>5.矩阵的转置函数 transpose()：</p>
<pre><code>b.transpose()       #实现矩阵行变列，列变行
</code></pre><p>6.调整大小，同reshape()函数功能相同，只不过函数resize()会改变所作用的数组</p>
<hr>
<h2 id="矩阵的合并"><a href="#矩阵的合并" class="headerlink" title="矩阵的合并"></a>矩阵的合并</h2><p><strong> 1.水平合并函数 hstack((a,b)) 和 concatenate((a,b),axis = 1)</strong></p>
<pre><code>import numpy as np
&gt;&gt;&gt; a = np.arange(9).reshape(3,3)
&gt;&gt;&gt; a
array([[0, 1, 2],
      [3, 4, 5],
      [6, 7, 8]])

&gt;&gt;&gt; b = a*2
&gt;&gt;&gt; b
array([[ 0,  2,  4],
      [ 6,  8, 10],
      [12, 14, 16]])

&gt;&gt;&gt; np.hstack((a,b))
array([[ 0,  1,  2,  0,  2,  4],
       [ 3,  4,  5,  6,  8, 10],
       [ 6,  7,  8, 12, 14, 16]])

&gt;&gt;&gt; np.concatenate((a,b),axis=1)
array([[ 0,  1,  2,  0,  2,  4],
       [ 3,  4,  5,  6,  8, 10],
       [ 6,  7,  8, 12, 14, 16]])
</code></pre><p><strong> 垂直合并函数vStack((a,b)) 和 concatenate((a,b),axis = 0) </strong></p>
<pre><code>&gt;&gt;&gt; np.vstack((a,b))
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 0,  2,  4],
       [ 6,  8, 10],
       [12, 14, 16]])

&gt;&gt;&gt; np.concatenate((a,b),axis = 0)  #同np.concatenate((a,b))   该函数axis默认参数为0
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 0,  2,  4],
       [ 6,  8, 10],
       [12, 14, 16]])
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python输入输出]]></title>
      <url>hubaoquan.github.io/2016/10/22/Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      <content type="html"><![CDATA[<h2 id="设置字符串的格式"><a href="#设置字符串的格式" class="headerlink" title="设置字符串的格式"></a>设置字符串的格式</h2><p>1.字符串插入：print（”%[d/e/x/X/e/E/F/s/%]” % 值 ）</p>
<p>2.格式字符串：”1/81 = {x:3f}”.format(x=1/81)   0.012</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python数据结构]]></title>
      <url>hubaoquan.github.io/2016/10/22/Python/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>1.元组是一种不可变的序列，可以包含零个或者多个值</p>
<p>2.元组的创建:  mytuple = (1,2,3,) ，mytuple2 = (())空元组，mytuple3=((1,))只有一个元素元组，注意不要省略“,”。</p>
<p>3.元组也可以进行拼接，与字符串一样</p>
<a id="more"></a>
<hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>1.列表是可变的元组，可以进行切片，可以进行拼接</p>
<p>2.列表里可以包含任何值</p>
<p>3.空列表用[]表示，单个元素[1],不用像元组加“,”</p>
<p>4.列表元素可以指向列表本身，称为自引用列表</p>
<p>5.常用函数：append()、count()、extend()、index()、insert()、pop()、remove()、reverse()、sort()</p>
<p>6.<strong>列表解析</strong>：【列表解析】常见的应用是修改现有列表<br>[n*n for n in range(1,10)]<br>得到：<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]</p>
<hr>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>1.字典的键是独一无二的</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>1.集合中没有重复元素，常用于去重操作</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python字符串]]></title>
      <url>hubaoquan.github.io/2016/10/21/Python/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>字符串的索引</p>
</blockquote>
<ol>
<li>负数索引，最后一个的下标为 <strong>-1</strong></li>
<li>ord(char c)函数可以将字符转化成对应ASCII码的十进制数，chr(int i)可以获得十进制数对应的ASCII字符，范围0~127。</li>
<li>str = ‘12345’ str[::-1] = ‘54321’,此方法可以方便的把字符串、列表逆转。</li>
<li>dir()函数可以查看当前Python窗口中的变量和函数 <a id="more"></a>
</li>
</ol>
<hr>
<blockquote>
<p>内置函数</p>
</blockquote>
<ol>
<li>‘capitalize’–将首字母大写 </li>
<li>‘center（width,char）’–将字符置于中间，宽度为width，用char填充两边 </li>
<li>‘s.count(t)’–t在s中出现的次数 </li>
<li>partition()将字符串拆分成多个子串。 </li>
<li>splitlines()如果字符串有多行，返回一个字符串列表，元素为每行字符串 </li>
<li>zfill()用零填充位数 </li>
<li>replace(old,new) </li>
<li>‘*‘.join(字符串列表)将字符串用*拼接起来<br><strong>‘decode’,’encode’, ‘endswith’, ‘expandtabs’, ‘find’, ‘format’, ‘index’, ‘isalnum’, ‘isalpha’, ‘isdigit’, ‘islower’, ‘isspace’, ‘istitle’, ‘isupper’, ‘join’, ‘ljust’, ‘lower’, ‘lstrip’, ‘partition’, ‘replace’, ‘rfind’, ‘rindex’, ‘rjust’, ‘rpartition’, ‘rsplit’, ‘rstrip’, ‘split’, ‘splitlines’, ‘startswith’, ‘strip’, ‘swapcase’, ‘title’, ‘translate’, ‘upper’, ‘zfill’</strong></li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
